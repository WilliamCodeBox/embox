"""
Coulomb's Law states that the force F between two point charges Q1 and Q2 is:

(1) Along the line joining them
(2) Directly proportional to the product Q1Q2 of the charges
(3) Inversely proportional to the square of the distance R between them
"""
from abc import ABC, abstractmethod
from typing import Union

import numpy as np

from ..math.vector import Vector


class Charge(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def force_on(self, other):
        raise NotImplementedError

    @abstractmethod
    def e_field_intensity(self, r):
        raise NotImplementedError


class PointCharge(Charge):
    def __init__(self, q: Union[int, float], r: Union[Vector, np.ndarray]):
        """
        Construct a charge by specifying its location and magnitude.
        :param q:
        :param r:
        """
        super().__init__()
        if len(r) != 3:
            raise ValueError("Location Vector must be 3 elements ndarray or an instance of Vector.")

        if isinstance(r, np.ndarray):
            self._loc = Vector(r[0], r[1], r[2])
        else:
            self._loc = r

        self._mag = q

    @property
    def loc(self):
        return self._loc

    @loc.setter
    def loc(self, r: Union[Vector, np.ndarray]):
        self._loc = r

    @property
    def mag(self):
        return self._mag

    @mag.setter
    def mag(self, q: Union[int, float]):
        self._mag = q

    def force_on(self, other: "PointCharge") -> Vector:
        """
        The force, generated by self, on another charge
        :param other: another Charge
        :return: The force between self and other
        """
        directional_vec = other.loc - self.loc
        r = directional_vec.mag

        k = 9.0E9
        force = k * self.mag * other._mag / (r * r)
        return force * directional_vec / r

    def e_field_intensity(self, r: Vector):
        """
        The electric field intensity at point r due to self which is located at self.locs
        :param r: the point where the e-field intensity is evaluated
        :return: The e-field intensity, located at r, generated by self
        """
        directional_vec = r - self.loc
        r = directional_vec.mag

        k = 9.0E9
        intensity = k * self.mag / (r * r)

        return intensity * directional_vec / r


class LineCharge(Charge):
    def __init__(self, rho: Union[int, float], start: Union[Vector, np.ndarray], end: Union[Vector, np.ndarray]):
        """
        A line charge with uniform charge density rho extending from start point to end point
        :param rho: the uniform charge density
        :param start: start point of the line
        :param end: end point of the line
        """
        super().__init__()
        self._rho = float(rho)

        if isinstance(start, np.ndarray):
            self._A = Vector(start[0], start[1], start[2])
        else:
            self._A = start

        if isinstance(end, np.ndarray):
            self._B = Vector(end[0], end[1], end[2])
        else:
            self._B = end

    @property
    def rho(self) -> float:
        return self._rho

    @rho.setter
    def rho(self, rho: Union[int, float]):
        self._rho = rho

    @property
    def start(self) -> Vector:
        return self._A

    @start.setter
    def start(self, start: Union[Vector, np.ndarray]):
        if isinstance(start, np.ndarray):
            self._A = Vector(start[0], start[1], start[2])
        else:
            self._A = start

    @property
    def end(self) -> Vector:
        return self._B

    @end.setter
    def end(self, end: Union[Vector, np.ndarray]):
        if isinstance(end, np.ndarray):
            self._B = Vector(end[0], end[1], end[2])
        else:
            self._B = end

    def force_on(self, other):
        pass

    def e_field_intensity(self, r: Vector):
        pass