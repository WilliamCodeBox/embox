"""
Coulomb's Law states that the force F between two point charges Q1 and Q2 is:

(1) Along the line joining them
(2) Directly proportional to the product Q1Q2 of the charges
(3) Inversely proportional to the square of the distance R between them
"""
from abc import ABC, abstractmethod
from typing import Union, NoReturn

import numpy as np

from .__log__ import logger
from ..geomesh.line import Line
from ..geomesh.point import Point
from ..math.vector import Vector


class Charge(ABC):
    def __init__(self, density: Union[int, float]) -> NoReturn:
        self._density = float(density)

    @property
    def rho(self) -> float:
        return self._density

    @rho.setter
    def rho(self, density: Union[int, float]) -> NoReturn:
        self._density = density

    @abstractmethod
    def force_on(self, other, **kwargs):
        raise NotImplementedError

    @abstractmethod
    def e_field_intensity(self, r: Union[Vector, list, np.ndarray], **kwargs):
        raise NotImplementedError


class PointCharge(Charge, Point):
    def __init__(self, coulomb: Union[int, float], loc: Union[Vector, list, np.ndarray]):
        """
        Construct a charge by specifying its location and magnitude.
        :param loc: the location of the point
        """
        Charge.__init__(self, coulomb)
        Point.__init__(self, loc)

    @property
    def coulomb(self):
        return self.rho

    @coulomb.setter
    def coulomb(self, coulomb: Union[int, float]):
        self.rho = coulomb

    def force_on(self, other: "PointCharge", **kwargs) -> Vector:
        """
        The force, generated by self, on another charge

        :param other: another Charge
        :return: The force between self and other
        """
        distance_vec = other.location - self.location
        r = distance_vec.length

        k = 9.0E9
        force = k * self.coulomb * other.coulomb / (r * r)
        return force * distance_vec / r

    def e_field_intensity(self, r: Vector, **kwargs) -> Vector:
        """
        The electric field intensity at point r due to self which is located at self.loc

        :param dx: Not used by PointCharge
        :param r: the point where the e-field intensity is evaluated
        :return: The e-field intensity, located at r, generated by self
        """
        distance_vec = r - self.location
        distance = distance_vec.length

        k = 9.0E9
        intensity = k * self.coulomb / (distance * distance)

        return intensity * distance_vec / distance


class LineCharge(Charge, Line):
    def __init__(self, rho: Union[int, float], start: Point, end: Point):
        """
        A Straight line charge with uniform charge density rho extending from start point to end point
        :param rho: the uniform charge density
        :param start: start point of the line
        :param end: end point of the line
        """
        Charge.__init__(self, rho)
        Line.__init__(self, start, end)

    @property
    def unit_vec(self):
        return (self.end_point.location - self.start_point.location).unit

    def force_on(self, point_charge: PointCharge, **kwargs):
        """
        Calculate the force on a point charge by self

        :param point_charge: the point charge
        :param kwargs: dx is required for numerical integral
        :return: the total force on point charge
        """
        if "dx" not in kwargs.keys():
            raise ValueError("LineCharge E-field intensity calculation needs dx for numerical integral")
        else:
            dx = kwargs["dx"]

        increment = dx * self.unit_vec

        N = int(np.floor((self.end_point.location - self.start_point.location).length / dx))
        logger.debug(f"Total line segments is {N}")
        logger.debug(f"Line charge force on {point_charge}")
        logger.debug(f"Unit vector along the line charge is {self.unit_vec}")
        logger.debug(f"Increment vector along the line charge is {increment}")

        total_force = Vector(0, 0, 0)
        loc = self.start_point.location
        for _ in range(N):
            q = PointCharge(self.rho * dx, loc)
            field = q.force_on(point_charge)
            loc += increment
            total_force += field
        return total_force

    def e_field_intensity(self, r: Union[Vector, np.ndarray], **kwargs) -> Vector:
        """
        Calculate the E-field intensity at given location by self

        :param r: the specified location
        :param kwargs: dx is required for numerical integral
        :return: the total E-field intensity at given location
        """
        if "dx" not in kwargs.keys():
            raise ValueError("LineCharge E-field intensity calculation needs dx for numerical integral")
        else:
            dx = kwargs["dx"]

        increment = dx * self.unit_vec

        N = int(np.floor((self.end_point.location - self.start_point.location).length / dx))
        logger.debug(f"Total line segments is {N}")
        logger.debug(f"Line charge e-field intensity at {r}")
        logger.debug(f"Unit vector along the line charge is {self.unit_vec}")
        logger.debug(f"Increment vector along the line charge is {increment}")
        total_field = Vector(0, 0, 0)
        loc = self.start_point.location
        for _ in range(N):
            q = PointCharge(self.rho * dx, loc)
            field = q.e_field_intensity(r)
            loc += increment
            total_field += field
        return total_field
