"""
Coulomb's Law states that the force F between two point charges Q1 and Q2 is:

(1) Along the line joining them
(2) Directly proportional to the product Q1Q2 of the charges
(3) Inversely proportional to the square of the distance R between them
"""
from abc import ABC, abstractmethod
from typing import Union, NoReturn

import numpy as np

from .__log__ import logger
from ..geomesh.point import Point
from ..math.vector import Vector


class Charge(ABC):
    def __init__(self, density: Union[int, float]) -> NoReturn:
        self._density = float(density)
        pass

    @property
    def density(self) -> float:
        return self._density

    @density.setter
    def density(self, density: Union[int, float]) -> NoReturn:
        self._density = density

    @abstractmethod
    def force_on(self, other, **kwargs):
        raise NotImplementedError

    @abstractmethod
    def e_field_intensity(self, r: Union[Vector, np.ndarray], **kwargs):
        raise NotImplementedError


class PointCharge(Charge, Point):
    def __init__(self, density: Union[int, float], loc: Union[Vector, np.ndarray]):
        """
        Construct a charge by specifying its location and magnitude.
        :param loc: the location of the point
        """
        super(PointCharge, self).__init__(density)
        super(PointCharge, self).__init__(loc)

        self._mag = density

    @property
    def mag(self):
        return self._mag

    @mag.setter
    def mag(self, q: Union[int, float]):
        self._mag = q

    def force_on(self, other: "PointCharge", **kwargs) -> Vector:
        """
        The force, generated by self, on another charge

        :param other: another Charge
        :return: The force between self and other
        """
        directional_vec = other.location - self.location
        r = directional_vec.mag

        k = 9.0E9
        force = k * self.mag * other._mag / (r * r)
        return force * directional_vec / r

    def e_field_intensity(self, r: Union[Vector, np.ndarray], **kwargs) -> Vector:
        """
        The electric field intensity at point r due to self which is located at self.loc

        :param dx: Not used by PointCharge
        :param r: the point where the e-field intensity is evaluated
        :return: The e-field intensity, located at r, generated by self
        """
        directional_vec = r - self.loc
        distance = directional_vec.mag

        k = 9.0E9
        intensity = k * self.mag / (distance * distance)

        return intensity * directional_vec / distance


class LineCharge(Charge):
    def __init__(self, rho: Union[int, float], start: Union[Vector, np.ndarray], end: Union[Vector, np.ndarray]):
        """
        A Straight line charge with uniform charge density rho extending from start point to end point
        :param rho: the uniform charge density
        :param start: start point of the line
        :param end: end point of the line
        """
        super().__init__()
        self._rho = float(rho)

        if isinstance(start, np.ndarray):
            self._A = Vector(start[0], start[1], start[2])
        else:
            self._A = start

        if isinstance(end, np.ndarray):
            self._B = Vector(end[0], end[1], end[2])
        else:
            self._B = end

    @property
    def rho(self) -> float:
        return self._rho

    @rho.setter
    def rho(self, rho: Union[int, float]):
        self._rho = rho

    @property
    def start(self) -> Vector:
        return self._A

    @start.setter
    def start(self, start: Union[Vector, np.ndarray]):
        if isinstance(start, np.ndarray):
            self._A = Vector(start[0], start[1], start[2])
        else:
            self._A = start

    @property
    def end(self) -> Vector:
        return self._B

    @end.setter
    def end(self, end: Union[Vector, np.ndarray]):
        if isinstance(end, np.ndarray):
            self._B = Vector(end[0], end[1], end[2])
        else:
            self._B = end

    @property
    def unit_vec(self):
        return (self.end - self.start).unit

    def force_on(self, point_charge: PointCharge, **kwargs):
        """
        Calculate the force on a point charge by self

        :param point_charge: the point charge
        :param kwargs: dx is required for numerical integral
        :return: the total force on point charge
        """
        if "dx" not in kwargs.keys():
            raise ValueError("LineCharge E-field intensity calculation needs dx for numerical integral")
        else:
            dx = kwargs["dx"]

        increment = dx * self.unit_vec

        N = int(np.floor((self.end - self.start).mag / dx))
        logger.debug(f"Total line segments is {N}")
        logger.debug(f"Line charge force on {point_charge}")
        logger.debug(f"Unit vector along the line charge is {self.unit_vec}")
        logger.debug(f"Increment vector along the line charge is {increment}")

        total_force = Vector(0, 0, 0)
        loc = self.start
        for _ in range(N):
            q = PointCharge(self.rho * dx, loc)
            field = q.force_on(point_charge)
            loc += increment
            total_force += field
        return total_force

    def e_field_intensity(self, r: Union[Vector, np.ndarray], **kwargs) -> Vector:
        """
        Calculate the E-field intensity at given location by self

        :param r: the specified location
        :param kwargs: dx is required for numerical integral
        :return: the total E-field intensity at given location
        """
        if "dx" not in kwargs.keys():
            raise ValueError("LineCharge E-field intensity calculation needs dx for numerical integral")
        else:
            dx = kwargs["dx"]

        increment = dx * self.unit_vec

        N = int(np.floor((self.end - self.start).mag / dx))
        logger.debug(f"Total line segments is {N}")
        logger.debug(f"Line charge e-field intensity at {r}")
        logger.debug(f"Unit vector along the line charge is {self.unit_vec}")
        logger.debug(f"Increment vector along the line charge is {increment}")
        total_field = Vector(0, 0, 0)
        loc = self.start
        for _ in range(N):
            q = PointCharge(self.rho * dx, loc)
            field = q.e_field_intensity(r)
            loc += increment
            total_field += field
        return total_field
